package hellojpa;

public class Persist {
    /*
        영속성 컨텍스트
        엔티티 매니저 팩토리와 엔티티 매니저
        - 엔티티를 영구 저장하는 환경 이라는 뜻
        EntityManager.persist(entity);
            - entity를 영속성 컨텍스트 라는 곳에 저장한다는 뜻;

        영속성 컨텍스트는 논리적인 개념
        눈에 보이지 않는다.
        엔티티 매니저를 통해서 영속성 컨텍스트에 접근;

        엔티티의 생명주기
        1. 비영속(new/transient)
        영속성 컨텍스트와 전혀 관계가 없는 새로운 상태

        2. 영속(managed)
        영속성 컨텍스트에 관리되는 상태

        3. 준영속(detached)
        영속성 컨텍스트에 저장되었다가 분리된 상태

        4. 삭제(removed)
        삭제된 상태

        영속성 컨텍스트의 이점
        1. 1차 캐시
            - 데이터 트랜잭션 단위로 만들고 끝나면 종료시킨다(영속성캐시가 지워진다.). 따라서 큰 이점을 얻기 힘들다.
        2. 동일성(identity) 보장
            - 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공.
        3. 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
            - 버퍼링을 모아서 write 를 할 수 있다. hibernate.jdbc.batch_size
        4. 변경 감지(Dirty Checking)
            - JPA가 스냅샷을 뜨면서 해당 값이 변경이 되면 commit 될 때 업데이트 된다.
        5. 지연 로딩(Lazy Loading)

        플러시 - 영속성 컨택스트의 변경내용을 데이터베이스에 반영, 데이터베이스 commit 되면 flush 가 자동으로 발생한다.
        1. 변경 감지
        2. 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
        3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

        영속성 컨텍스트를 플러시하는 방법
        - em.flush - 직접 호출
        - 트랜잭션 커밋 - 플러시 자동 호출
        - JPQL 쿼리 실행 - 플러시 자동 호출
         : 쿼리를 날렸을 때 기존에 쓰기 지연 SQL 저장소에 있는 걸 반영하기 위해(에러를 막고자) flush를 날려버린다.

         플러시 모드 옵션
         em.setFlushMode(FlushModeType.COMMIT)
         FlushModeType.AUTO - 기본모드, 커밋이나 쿼리를 실행할 때 플러시(기본값)
         FlushModeType.COMMIT - 커밋할 때만 플러시

         플리서는!
         - 영속성 컨텍스트(1차캐시)를 비우지 않음
         - 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화
         - 트랜잭셩이라는 작업 단위가 중요 -> 커밋 직접에만 동기화 하면 됨.

         준영속 상태
         - 영속 -> 준영속
         - 영속 상태의 엔티티가 영속성 컨테스트에서 분리(detached)
         - 영속성 컨텍스트가 제공하는 기능을 사용 못함

         준영속 상태로 만드는 방법
         - em.detach(entity), 특정 엔티티만 준영속 상태로 전환
         - em.clear(), 영속성 컨테스트를 완전히 초기화
         - em.close(), 영속성 컨텍스트를 종료

     */
}
